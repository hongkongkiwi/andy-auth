# Cursor Rules for Project with Zenstack UI

Languages:
  - TypeScript (primary)
  - JavaScript (legacy support only)

Frameworks and Libraries:
  - Next.js 14+ with App Router
  - Shadcn UI
  - Zenstack
  - Zenstack UI (Autogenerated Forms)
  - Zustand (State Management)
  - React Hook Form + Zod
  - Tailwind CSS
  - Lucide Icons
  - Better-Auth (Authentication)

Component Architecture:
  - Use arrow function components with explicit type interfaces
  - Prefer server components, use 'use client' only when necessary
  - Implement layout patterns with nested routing structure
  - Follow atomic design principles for UI components

Best Practices:
  - Define Zod schemas for all form validations
  - Use Zenstack UI for CRUD operations with proper type safety
  - Implement proper error boundaries and loading states
  - Follow established folder structure patterns:
    - (group) folders for route grouping
    - _components for route-specific components
    - Separate layout.tsx for each route group
  - Use custom hooks for shared logic
  - Implement proper TypeScript interfaces for all props
  - Use context providers for workspace and client state
  - Import from '@zenstackhq/runtime/models':
    - Types and enums
    - Use grouped imports for multiple items:
      import { 
        WorkspaceStatus,
        ClientStatus,
        PlatformUserStatus 
      } from '@zenstackhq/runtime/models'
    - Use single-line imports for individual items:
      import { WorkspaceStatus } from '@zenstackhq/runtime/models'

Code Style:
  - Use arrow functions for component definitions
  - Follow established naming conventions:
    - PascalCase for components
    - camelCase for functions and variables
    - UPPER_CASE for constants
  - Use type interfaces over type aliases
  - Implement proper prop typing with optional properties
  - Use destructuring for props
  - Maintain consistent file structure:
    - Exports at bottom of file
    - Types/interfaces at top
    - Hooks before render logic

State Management:
  - Use Zustand for global state
  - Implement context for scoped state (workspace/client)
  - Follow established store patterns with proper typing
  - Use proper action creators and state selectors

Form Handling:
  - Use Zenstack UI for generated forms
  - Use Zenstack-generated Zod schemas for form validation:
    - Import from '@zenstack/zod/models/{Model}.schema'
    - Use {Model}CreateSchema for creation forms
    - Use {Model}UpdateSchema for update forms
  - Use react-hook-form for complex form scenarios

Type Safety:
  - Use Zenstack-generated types for all database operations
  - Import model types from '@zenstackhq/runtime/models'
  - For Prisma imports:
    - Always import PrismaClient and Prisma from '@prisma/client':
      import { PrismaClient, Prisma } from '@prisma/client'
    - Never import these from Zenstack packages
  - For enums:
    - Use '@zenstackhq/runtime/models' when used as types
    - Use '@prisma/client' when used as values
    - Example:
      // For type usage
      import type { PlatformUserStatus } from '@zenstackhq/runtime/models'
      // For value usage
      import { PlatformUserStatus } from '@prisma/client'
  - Use Zenstack-generated Zod schemas for runtime validation
  - Implement proper type guards for enum values
  - Follow established type safety patterns for:
    - Form inputs
    - API responses
    - State management
    - Component props

Route Organization:
  - Use proper route grouping:
    - (auth) - Authentication routes
    - (dashboard) - Protected dashboard routes
    - (api) - API routes
  - Implement proper layouts per group
  - Use proper loading and error boundaries

Error Handling:
  - Implement proper error boundaries
  - Use consistent error messages
  - Handle API errors properly
  - Implement proper validation error handling
  - Use proper error logging

Database Operations:
  - Use transactions for operations that:
    - Modify multiple records
    - Require data consistency across tables
    - Need atomic updates
  - Single-record operations can use direct queries
  - Follow retry patterns for retryable errors
  - Implement proper error handling for database operations
  - Use proper timeouts for queries and transactions

Data Model Relationships:
  User -> Workspace:
    - User has zero or more Workspaces
    - User must have WorkspacePermissions to access a Workspace
    - WorkspacePermissions:
      - READ: Can view workspace details
      - WRITE: Can edit workspace settings
      - ADMIN: Full workspace control

  Workspace -> Client:
    - Workspace has zero or more Clients
    - User must have ClientPermissions to access a Client
    - ClientPermissions:
      - READ: Can view client details
      - WRITE: Can edit client information
      - ADMIN: Full client control

  Client -> Patrol:
    - Client has zero or more Patrols
    - User must have ClientPatrolPermissions to access a Patrol
    - ClientPatrolPermissions:
      - READ: Can view patrol details
      - WRITE: Can edit patrol information
      - ADMIN: Full patrol control

  Permission Inheritance:
    - Workspace ADMIN can manage all Clients in Workspace
    - Client ADMIN can manage all Patrols for that Client
    - Permissions do not automatically cascade down
    - Each level requires explicit permission grants

References:
  Documentation:
    - Zenstack: https://zenstack.dev/docs
    - Zenstack UI: https://ui.zenstack.dev
    - Next.js App Router: https://nextjs.org/docs/app
    - Shadcn UI: https://ui.shadcn.com
    - Zustand: https://docs.pmnd.rs/zustand
    - Better-Auth: https://www.better-auth.com

  Imports:
    - '@prisma/client': enums
    - '@zenstackhq/runtime/models': Types
    - '@zenstackhq/runtime/zod/models': Zod schemas
    - '@zenstack/ui/forms': Form generation
    - '@zenstack/ui/crud': CRUD operations
    - 'better-auth': Authentication

# Note: Ensure that your implementation of @db permissions is complete and functioning without placeholders.