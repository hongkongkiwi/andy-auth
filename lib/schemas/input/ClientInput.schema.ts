/******************************************************************************
 * This file was generated by ZenStack CLI.
 ******************************************************************************/

/* eslint-disable */
// @ts-nocheck

import { z } from 'zod';
import type { Prisma } from '@zenstackhq/runtime/models';

import { ClientSelectObjectSchema } from '../objects/ClientSelect.schema';
import { ClientIncludeObjectSchema } from '../objects/ClientInclude.schema';
import { ClientWhereUniqueInputObjectSchema } from '../objects/ClientWhereUniqueInput.schema';
import { ClientWhereInputObjectSchema } from '../objects/ClientWhereInput.schema';
import { ClientOrderByWithRelationInputObjectSchema } from '../objects/ClientOrderByWithRelationInput.schema';
import { ClientScalarFieldEnumSchema } from '../enums/ClientScalarFieldEnum.schema';
import { ClientCreateInputObjectSchema } from '../objects/ClientCreateInput.schema';
import { ClientUncheckedCreateInputObjectSchema } from '../objects/ClientUncheckedCreateInput.schema';
import { ClientCreateManyInputObjectSchema } from '../objects/ClientCreateManyInput.schema';
import { ClientUpdateInputObjectSchema } from '../objects/ClientUpdateInput.schema';
import { ClientUncheckedUpdateInputObjectSchema } from '../objects/ClientUncheckedUpdateInput.schema';
import { ClientUpdateManyMutationInputObjectSchema } from '../objects/ClientUpdateManyMutationInput.schema';
import { ClientUncheckedUpdateManyInputObjectSchema } from '../objects/ClientUncheckedUpdateManyInput.schema';
import { ClientCountAggregateInputObjectSchema } from '../objects/ClientCountAggregateInput.schema';
import { ClientMinAggregateInputObjectSchema } from '../objects/ClientMinAggregateInput.schema';
import { ClientMaxAggregateInputObjectSchema } from '../objects/ClientMaxAggregateInput.schema';
import { ClientAvgAggregateInputObjectSchema } from '../objects/ClientAvgAggregateInput.schema';
import { ClientSumAggregateInputObjectSchema } from '../objects/ClientSumAggregateInput.schema';
import { ClientOrderByWithAggregationInputObjectSchema } from '../objects/ClientOrderByWithAggregationInput.schema';
import { ClientScalarWhereWithAggregatesInputObjectSchema } from '../objects/ClientScalarWhereWithAggregatesInput.schema';

type ClientInputSchemaType = {
  findUnique: z.ZodType<Prisma.ClientFindUniqueArgs>;
  findFirst: z.ZodType<Prisma.ClientFindFirstArgs>;
  findMany: z.ZodType<Prisma.ClientFindManyArgs>;
  create: z.ZodType<Prisma.ClientCreateArgs>;
  createMany: z.ZodType<Prisma.ClientCreateManyArgs>;
  delete: z.ZodType<Prisma.ClientDeleteArgs>;
  deleteMany: z.ZodType<Prisma.ClientDeleteManyArgs>;
  update: z.ZodType<Prisma.ClientUpdateArgs>;
  updateMany: z.ZodType<Prisma.ClientUpdateManyArgs>;
  upsert: z.ZodType<Prisma.ClientUpsertArgs>;
  aggregate: z.ZodType<Prisma.ClientAggregateArgs>;
  groupBy: z.ZodType<Prisma.ClientGroupByArgs>;
  count: z.ZodType<Prisma.ClientCountArgs>;
};

export const ClientInputSchema = {
  findUnique: z
    .object({
      select: z.lazy(() => ClientSelectObjectSchema.optional()),
      include: z.lazy(() => ClientIncludeObjectSchema.optional()),
      where: ClientWhereUniqueInputObjectSchema
    })
    .strict(),
  findFirst: z
    .object({
      select: z.lazy(() => ClientSelectObjectSchema.optional()),
      include: z.lazy(() => ClientIncludeObjectSchema.optional()),
      where: ClientWhereInputObjectSchema.optional(),
      orderBy: z
        .union([
          ClientOrderByWithRelationInputObjectSchema,
          ClientOrderByWithRelationInputObjectSchema.array()
        ])
        .optional(),
      cursor: ClientWhereUniqueInputObjectSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z.array(ClientScalarFieldEnumSchema).optional()
    })
    .strict(),
  findMany: z
    .object({
      select: z.lazy(() => ClientSelectObjectSchema.optional()),
      include: z.lazy(() => ClientIncludeObjectSchema.optional()),
      where: ClientWhereInputObjectSchema.optional(),
      orderBy: z
        .union([
          ClientOrderByWithRelationInputObjectSchema,
          ClientOrderByWithRelationInputObjectSchema.array()
        ])
        .optional(),
      cursor: ClientWhereUniqueInputObjectSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z.array(ClientScalarFieldEnumSchema).optional()
    })
    .strict(),
  create: z
    .object({
      select: z.lazy(() => ClientSelectObjectSchema.optional()),
      include: z.lazy(() => ClientIncludeObjectSchema.optional()),
      data: z.union([
        ClientCreateInputObjectSchema,
        ClientUncheckedCreateInputObjectSchema
      ])
    })
    .strict(),
  createMany: z
    .object({
      data: z.union([
        ClientCreateManyInputObjectSchema,
        z.array(ClientCreateManyInputObjectSchema)
      ]),
      skipDuplicates: z.boolean().optional()
    })
    .strict(),
  delete: z
    .object({
      select: z.lazy(() => ClientSelectObjectSchema.optional()),
      include: z.lazy(() => ClientIncludeObjectSchema.optional()),
      where: ClientWhereUniqueInputObjectSchema
    })
    .strict(),
  deleteMany: z
    .object({
      where: ClientWhereInputObjectSchema.optional()
    })
    .strict(),
  update: z
    .object({
      select: z.lazy(() => ClientSelectObjectSchema.optional()),
      include: z.lazy(() => ClientIncludeObjectSchema.optional()),
      data: z.union([
        ClientUpdateInputObjectSchema,
        ClientUncheckedUpdateInputObjectSchema
      ]),
      where: ClientWhereUniqueInputObjectSchema
    })
    .strict(),
  updateMany: z
    .object({
      data: z.union([
        ClientUpdateManyMutationInputObjectSchema,
        ClientUncheckedUpdateManyInputObjectSchema
      ]),
      where: ClientWhereInputObjectSchema.optional()
    })
    .strict(),
  upsert: z
    .object({
      select: z.lazy(() => ClientSelectObjectSchema.optional()),
      include: z.lazy(() => ClientIncludeObjectSchema.optional()),
      where: ClientWhereUniqueInputObjectSchema,
      create: z.union([
        ClientCreateInputObjectSchema,
        ClientUncheckedCreateInputObjectSchema
      ]),
      update: z.union([
        ClientUpdateInputObjectSchema,
        ClientUncheckedUpdateInputObjectSchema
      ])
    })
    .strict(),
  aggregate: z
    .object({
      where: ClientWhereInputObjectSchema.optional(),
      orderBy: z
        .union([
          ClientOrderByWithRelationInputObjectSchema,
          ClientOrderByWithRelationInputObjectSchema.array()
        ])
        .optional(),
      cursor: ClientWhereUniqueInputObjectSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      _count: z
        .union([z.literal(true), ClientCountAggregateInputObjectSchema])
        .optional(),
      _min: ClientMinAggregateInputObjectSchema.optional(),
      _max: ClientMaxAggregateInputObjectSchema.optional(),
      _avg: ClientAvgAggregateInputObjectSchema.optional(),
      _sum: ClientSumAggregateInputObjectSchema.optional()
    })
    .strict(),
  groupBy: z
    .object({
      where: ClientWhereInputObjectSchema.optional(),
      orderBy: z
        .union([
          ClientOrderByWithAggregationInputObjectSchema,
          ClientOrderByWithAggregationInputObjectSchema.array()
        ])
        .optional(),
      having: ClientScalarWhereWithAggregatesInputObjectSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      by: z.array(ClientScalarFieldEnumSchema),
      _count: z
        .union([z.literal(true), ClientCountAggregateInputObjectSchema])
        .optional(),
      _min: ClientMinAggregateInputObjectSchema.optional(),
      _max: ClientMaxAggregateInputObjectSchema.optional(),
      _avg: ClientAvgAggregateInputObjectSchema.optional(),
      _sum: ClientSumAggregateInputObjectSchema.optional()
    })
    .strict(),
  count: z
    .object({
      where: ClientWhereInputObjectSchema.optional(),
      orderBy: z
        .union([
          ClientOrderByWithRelationInputObjectSchema,
          ClientOrderByWithRelationInputObjectSchema.array()
        ])
        .optional(),
      cursor: ClientWhereUniqueInputObjectSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z.array(ClientScalarFieldEnumSchema).optional(),
      select: z
        .union([z.literal(true), ClientCountAggregateInputObjectSchema])
        .optional()
    })
    .strict()
} as ClientInputSchemaType;
