/******************************************************************************
 * This file was generated by ZenStack CLI.
 ******************************************************************************/

/* eslint-disable */
// @ts-nocheck

import { z } from 'zod';
import type { Prisma } from '@zenstackhq/runtime/models';

import { IncidentSelectObjectSchema } from '../objects/IncidentSelect.schema';
import { IncidentIncludeObjectSchema } from '../objects/IncidentInclude.schema';
import { IncidentWhereUniqueInputObjectSchema } from '../objects/IncidentWhereUniqueInput.schema';
import { IncidentWhereInputObjectSchema } from '../objects/IncidentWhereInput.schema';
import { IncidentOrderByWithRelationInputObjectSchema } from '../objects/IncidentOrderByWithRelationInput.schema';
import { IncidentScalarFieldEnumSchema } from '../enums/IncidentScalarFieldEnum.schema';
import { IncidentCreateInputObjectSchema } from '../objects/IncidentCreateInput.schema';
import { IncidentUncheckedCreateInputObjectSchema } from '../objects/IncidentUncheckedCreateInput.schema';
import { IncidentCreateManyInputObjectSchema } from '../objects/IncidentCreateManyInput.schema';
import { IncidentUpdateInputObjectSchema } from '../objects/IncidentUpdateInput.schema';
import { IncidentUncheckedUpdateInputObjectSchema } from '../objects/IncidentUncheckedUpdateInput.schema';
import { IncidentUpdateManyMutationInputObjectSchema } from '../objects/IncidentUpdateManyMutationInput.schema';
import { IncidentUncheckedUpdateManyInputObjectSchema } from '../objects/IncidentUncheckedUpdateManyInput.schema';
import { IncidentCountAggregateInputObjectSchema } from '../objects/IncidentCountAggregateInput.schema';
import { IncidentMinAggregateInputObjectSchema } from '../objects/IncidentMinAggregateInput.schema';
import { IncidentMaxAggregateInputObjectSchema } from '../objects/IncidentMaxAggregateInput.schema';
import { IncidentAvgAggregateInputObjectSchema } from '../objects/IncidentAvgAggregateInput.schema';
import { IncidentSumAggregateInputObjectSchema } from '../objects/IncidentSumAggregateInput.schema';
import { IncidentOrderByWithAggregationInputObjectSchema } from '../objects/IncidentOrderByWithAggregationInput.schema';
import { IncidentScalarWhereWithAggregatesInputObjectSchema } from '../objects/IncidentScalarWhereWithAggregatesInput.schema';

type IncidentInputSchemaType = {
  findUnique: z.ZodType<Prisma.IncidentFindUniqueArgs>;
  findFirst: z.ZodType<Prisma.IncidentFindFirstArgs>;
  findMany: z.ZodType<Prisma.IncidentFindManyArgs>;
  create: z.ZodType<Prisma.IncidentCreateArgs>;
  createMany: z.ZodType<Prisma.IncidentCreateManyArgs>;
  delete: z.ZodType<Prisma.IncidentDeleteArgs>;
  deleteMany: z.ZodType<Prisma.IncidentDeleteManyArgs>;
  update: z.ZodType<Prisma.IncidentUpdateArgs>;
  updateMany: z.ZodType<Prisma.IncidentUpdateManyArgs>;
  upsert: z.ZodType<Prisma.IncidentUpsertArgs>;
  aggregate: z.ZodType<Prisma.IncidentAggregateArgs>;
  groupBy: z.ZodType<Prisma.IncidentGroupByArgs>;
  count: z.ZodType<Prisma.IncidentCountArgs>;
};

export const IncidentInputSchema = {
  findUnique: z
    .object({
      select: z.lazy(() => IncidentSelectObjectSchema.optional()),
      include: z.lazy(() => IncidentIncludeObjectSchema.optional()),
      where: IncidentWhereUniqueInputObjectSchema
    })
    .strict(),
  findFirst: z
    .object({
      select: z.lazy(() => IncidentSelectObjectSchema.optional()),
      include: z.lazy(() => IncidentIncludeObjectSchema.optional()),
      where: IncidentWhereInputObjectSchema.optional(),
      orderBy: z
        .union([
          IncidentOrderByWithRelationInputObjectSchema,
          IncidentOrderByWithRelationInputObjectSchema.array()
        ])
        .optional(),
      cursor: IncidentWhereUniqueInputObjectSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z.array(IncidentScalarFieldEnumSchema).optional()
    })
    .strict(),
  findMany: z
    .object({
      select: z.lazy(() => IncidentSelectObjectSchema.optional()),
      include: z.lazy(() => IncidentIncludeObjectSchema.optional()),
      where: IncidentWhereInputObjectSchema.optional(),
      orderBy: z
        .union([
          IncidentOrderByWithRelationInputObjectSchema,
          IncidentOrderByWithRelationInputObjectSchema.array()
        ])
        .optional(),
      cursor: IncidentWhereUniqueInputObjectSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z.array(IncidentScalarFieldEnumSchema).optional()
    })
    .strict(),
  create: z
    .object({
      select: z.lazy(() => IncidentSelectObjectSchema.optional()),
      include: z.lazy(() => IncidentIncludeObjectSchema.optional()),
      data: z.union([
        IncidentCreateInputObjectSchema,
        IncidentUncheckedCreateInputObjectSchema
      ])
    })
    .strict(),
  createMany: z
    .object({
      data: z.union([
        IncidentCreateManyInputObjectSchema,
        z.array(IncidentCreateManyInputObjectSchema)
      ]),
      skipDuplicates: z.boolean().optional()
    })
    .strict(),
  delete: z
    .object({
      select: z.lazy(() => IncidentSelectObjectSchema.optional()),
      include: z.lazy(() => IncidentIncludeObjectSchema.optional()),
      where: IncidentWhereUniqueInputObjectSchema
    })
    .strict(),
  deleteMany: z
    .object({
      where: IncidentWhereInputObjectSchema.optional()
    })
    .strict(),
  update: z
    .object({
      select: z.lazy(() => IncidentSelectObjectSchema.optional()),
      include: z.lazy(() => IncidentIncludeObjectSchema.optional()),
      data: z.union([
        IncidentUpdateInputObjectSchema,
        IncidentUncheckedUpdateInputObjectSchema
      ]),
      where: IncidentWhereUniqueInputObjectSchema
    })
    .strict(),
  updateMany: z
    .object({
      data: z.union([
        IncidentUpdateManyMutationInputObjectSchema,
        IncidentUncheckedUpdateManyInputObjectSchema
      ]),
      where: IncidentWhereInputObjectSchema.optional()
    })
    .strict(),
  upsert: z
    .object({
      select: z.lazy(() => IncidentSelectObjectSchema.optional()),
      include: z.lazy(() => IncidentIncludeObjectSchema.optional()),
      where: IncidentWhereUniqueInputObjectSchema,
      create: z.union([
        IncidentCreateInputObjectSchema,
        IncidentUncheckedCreateInputObjectSchema
      ]),
      update: z.union([
        IncidentUpdateInputObjectSchema,
        IncidentUncheckedUpdateInputObjectSchema
      ])
    })
    .strict(),
  aggregate: z
    .object({
      where: IncidentWhereInputObjectSchema.optional(),
      orderBy: z
        .union([
          IncidentOrderByWithRelationInputObjectSchema,
          IncidentOrderByWithRelationInputObjectSchema.array()
        ])
        .optional(),
      cursor: IncidentWhereUniqueInputObjectSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      _count: z
        .union([z.literal(true), IncidentCountAggregateInputObjectSchema])
        .optional(),
      _min: IncidentMinAggregateInputObjectSchema.optional(),
      _max: IncidentMaxAggregateInputObjectSchema.optional(),
      _avg: IncidentAvgAggregateInputObjectSchema.optional(),
      _sum: IncidentSumAggregateInputObjectSchema.optional()
    })
    .strict(),
  groupBy: z
    .object({
      where: IncidentWhereInputObjectSchema.optional(),
      orderBy: z
        .union([
          IncidentOrderByWithAggregationInputObjectSchema,
          IncidentOrderByWithAggregationInputObjectSchema.array()
        ])
        .optional(),
      having: IncidentScalarWhereWithAggregatesInputObjectSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      by: z.array(IncidentScalarFieldEnumSchema),
      _count: z
        .union([z.literal(true), IncidentCountAggregateInputObjectSchema])
        .optional(),
      _min: IncidentMinAggregateInputObjectSchema.optional(),
      _max: IncidentMaxAggregateInputObjectSchema.optional(),
      _avg: IncidentAvgAggregateInputObjectSchema.optional(),
      _sum: IncidentSumAggregateInputObjectSchema.optional()
    })
    .strict(),
  count: z
    .object({
      where: IncidentWhereInputObjectSchema.optional(),
      orderBy: z
        .union([
          IncidentOrderByWithRelationInputObjectSchema,
          IncidentOrderByWithRelationInputObjectSchema.array()
        ])
        .optional(),
      cursor: IncidentWhereUniqueInputObjectSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z.array(IncidentScalarFieldEnumSchema).optional(),
      select: z
        .union([z.literal(true), IncidentCountAggregateInputObjectSchema])
        .optional()
    })
    .strict()
} as IncidentInputSchemaType;
